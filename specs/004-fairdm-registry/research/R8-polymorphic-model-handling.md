# Research Task R8: Polymorphic Model Handling

**Research Date**: January 12, 2026
**Researcher**: GitHub Copilot
**Status**: Complete

## Executive Summary

Django-polymorphic adds two primary fields to models (`polymorphic_ctype` and `polymorphic_ctype_id`) plus multi-table inheritance pointer fields (e.g., `sample_ptr`, `sample_ptr_id`) for child models. All of these technical fields should be excluded from auto-generated components to avoid confusion and form errors. The registry should use `Model.__subclasses__()` to detect Sample vs Measurement subclasses, and polymorphic querysets work seamlessly with django-tables2 and django-filter but require understanding of special filtering syntax.

## Research Questions Answered

### 1. What special fields does django-polymorphic add to models?

Django-polymorphic adds the following fields to models:

**Base Polymorphic Fields** (added to all polymorphic models):

- `polymorphic_ctype` - ForeignKey to ContentType, tracks the actual model class
- `polymorphic_ctype_id` - Integer FK ID field (auto-generated by Django)

**Multi-table Inheritance Pointer Fields** (added to child models):

- `{parent_name}_ptr` - OneToOneField pointer to parent (e.g., `sample_ptr`, `measurement_ptr`)
- `{parent_name}_ptr_id` - Integer FK ID field (e.g., `sample_ptr_id`)

**Evidence from codebase**:

```python
# From fairdm/utils/inspection.py lines 28-40
ALWAYS_EXCLUDE = [
    "id",
    "polymorphic_ctype",
    "polymorphic_ctype_id",
]

# Field name patterns to exclude
EXCLUDE_PATTERNS = [
    "_ptr",  # Polymorphic pointer fields
    "_ptr_id",
    "password",  # Security sensitive
]
```

**Evidence from django-polymorphic documentation**:

```python
# Django migration showing polymorphic_ctype field structure
migrations.AddField(
    model_name='mymodel',
    name='polymorphic_ctype',
    field=models.ForeignKey(
        related_name='polymorphic_myapp.mymodel_set+'
        editable=False,
        to='contenttypes.ContentType',
        null=True
    ),
)
```

### 2. Should polymorphic_ctype and other polymorphic fields be excluded from auto-generated components?

**Decision**: YES - All polymorphic technical fields MUST be excluded from auto-generated forms, tables, filters, serializers, and admin components.

**Rationale**:

1. **Forms**: Including `polymorphic_ctype` causes `AttributeError: can't set attribute` when saving
2. **User Experience**: These are internal Django/polymorphic fields with no user-facing value
3. **Data Integrity**: Polymorphic fields are managed automatically by django-polymorphic
4. **Consistency**: FairDM already excludes these fields in multiple locations

**Evidence from django-polymorphic docs**:
> "To add a polymorphic child model as an Inline for another model, add a field to the inline's readonly_fields list formed by the lowercased name of the polymorphic parent model with the string_ptr appended to it. Otherwise, trying to save that model in the admin will raise an AttributeError with the message 'can't set attribute'."

**Current exclusion in FairDM**:

```python
# From fairdm/core/base.py lines 209-217 (get_resource_class)
kwargs = {
    "fields": self.get_fields(),
    "exclude": [
        "polymorphic_ctype",
        "sample_ptr",
        "image",
        "keywords",
        "created",
        "modified",
        "options",
        # ...
    ],
}
```

```python
# From fairdm/core/utils.py lines 40-51
declared_fields = {
    "id",
    "local_id",
    "sample_ptr",
    "polymorphic_ctype",
    "created",
    "modified",
    "options",
    # ...
}
```

### 3. Does polymorphic queryset behavior impact component generation?

**Answer**: Polymorphic querysets work transparently with django-tables2 and django-filter, but developers must understand special filtering syntax.

**Key Points**:

**No Special Handling Needed for Tables/Filters**:

- Django-tables2 and django-filter work with polymorphic querysets out of the box
- Polymorphic querysets automatically return correctly-typed instances
- No special configuration needed in Table or FilterSet classes

**Special Filtering Syntax Available** (not required, but useful):

```python
# Triple underscore syntax for filtering by child-specific fields
Project.objects.filter(ArtProject___artist='T. Turner')

# instance_of() for type-based filtering
Project.objects.instance_of(ArtProject)

# not_instance_of() for excluding types
Project.objects.not_instance_of(ArchivedProject)
```

**Performance Consideration**:

```python
# Use non_polymorphic() when only base fields needed (optimization)
Project.objects.non_polymorphic()
```

**Evidence from django-polymorphic docs**:
> "The library integrates deeply with Django's ORM, admin interface, and forms system. It supports advanced querying with polymorphic-aware filtering and ordering, provides specialized admin classes for managing polymorphic model hierarchies, and includes formset support for handling collections of polymorphic objects."

### 4. How should the registry detect Sample vs Measurement subclasses?

**Decision**: Use `Model.__subclasses__()` as specified in FR-016.

**Detection Strategy**:

```python
# From specification (FR-016)
# The registry MUST detect polymorphic models using Model.__subclasses__()

from fairdm.core.models import Sample, Measurement

# Get all Sample subclasses
sample_models = Sample.__subclasses__()

# Get all Measurement subclasses
measurement_models = Measurement.__subclasses__()

# Recursive detection for multi-level inheritance
def get_all_subclasses(model):
    """Recursively get all subclasses of a model."""
    direct = model.__subclasses__()
    indirect = [sub for child in direct for sub in get_all_subclasses(child)]
    return direct + indirect

all_samples = get_all_subclasses(Sample)
all_measurements = get_all_subclasses(Measurement)
```

**Registry Implementation Pattern**:

```python
class FairDMRegistry:
    @property
    def samples(self):
        """Returns list of all registered Sample model classes."""
        from fairdm.core.models import Sample
        return [
            config.model
            for config in self._registry.values()
            if issubclass(config.model, Sample)
        ]

    @property
    def measurements(self):
        """Returns list of all registered Measurement model classes."""
        from fairdm.core.models import Measurement
        return [
            config.model
            for config in self._registry.values()
            if issubclass(config.model, Measurement)
        ]
```

**Evidence from FairDM models**:

```python
# From fairdm/core/sample/models.py lines 17-18
class Sample(BasePolymorphicModel):
    @classproperty
    def type_of(self):
        return Sample

# From fairdm/core/measurement/models.py lines 16-17
class Measurement(BasePolymorphicModel):
    @classproperty
    def type_of(self):
        return Measurement
```

### 5. Are there any gotchas with polymorphic models and forms/tables/filters?

**Yes - Several Important Gotchas**:

#### Gotcha 1: Admin Inline `AttributeError`

**Problem**: Adding polymorphic child models as inlines causes "can't set attribute" error.

**Solution**: Add parent pointer field to `readonly_fields`:

```python
class ModelBInline(admin.StackedInline):
    model = ModelB
    fk_name = 'modelb'
    readonly_fields = ['modela_ptr']  # Critical!
```

#### Gotcha 2: Form Field Conflicts

**Problem**: Including `polymorphic_ctype` or `_ptr` fields in forms causes save errors.

**Solution**: Always exclude these fields:

```python
class Meta:
    model = CustomSample
    exclude = ['polymorphic_ctype', 'polymorphic_ctype_id', 'sample_ptr', 'sample_ptr_id']
```

#### Gotcha 3: Serializer Deep Nesting

**Problem**: DRF serializers may include unwanted polymorphic fields by default.

**Solution**: Explicitly exclude in serializer Meta:

```python
class SampleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Sample
        exclude = ['polymorphic_ctype']
```

#### Gotcha 4: FilterSet on Child-Specific Fields

**Problem**: Base model FilterSet can't filter by child-specific fields using standard syntax.

**Solution**: Use triple underscore syntax or create child-specific FilterSets:

```python
# Option 1: Triple underscore (requires custom filter implementation)
class ProjectFilter(FilterSet):
    artist = CharFilter(field_name='ArtProject___artist')

# Option 2: Separate FilterSets per child type (recommended)
class ArtProjectFilter(FilterSet):
    class Meta:
        model = ArtProject
        fields = ['artist', 'topic']
```

#### Gotcha 5: Table Column Display for Mixed Types

**Problem**: Table columns for child-specific fields show empty values for wrong types.

**Solution**: Use accessor methods or custom render methods:

```python
class ProjectTable(Table):
    artist = Column(accessor='artproject.artist', default='N/A')

    def render_artist(self, record):
        if isinstance(record, ArtProject):
            return record.artist
        return 'N/A'
```

#### Gotcha 6: Proxy Model Confusion

**Problem**: Proxy models inherit polymorphic behavior but share the same ContentType.

**Solution**: Ensure proxy models properly set `polymorphic_ctype` on save:

```python
class PublishedDocument(Document):
    class Meta:
        proxy = True

    def save(self, *args, **kwargs):
        self.status = 'published'
        super().save(*args, **kwargs)
```

#### Gotcha 7: Dumpdata/Loaddata Issues

**Problem**: Fixture loading may fail to preserve ContentType references.

**Solution**: Use natural keys:

```bash
# Export
python manage.py dumpdata --natural-primary --natural-foreign

# Import
python manage.py loaddata fixture.json
```

## Complete List of Polymorphic Fields to Exclude

### Always Exclude from Auto-Generation

```python
POLYMORPHIC_EXCLUDE_FIELDS = [
    # Django-polymorphic base fields
    "polymorphic_ctype",
    "polymorphic_ctype_id",

    # Multi-table inheritance pointer fields (pattern-based)
    # Any field matching these patterns:
    # - Ends with "_ptr"
    # - Ends with "_ptr_id"

    # Common examples in FairDM:
    "sample_ptr",
    "sample_ptr_id",
    "measurement_ptr",
    "measurement_ptr_id",
]

POLYMORPHIC_EXCLUDE_PATTERNS = [
    "_ptr",      # Matches: sample_ptr, measurement_ptr, etc.
    "_ptr_id",   # Matches: sample_ptr_id, measurement_ptr_id, etc.
]
```

### Field Detection Algorithm

```python
def should_exclude_field(field_name: str, field: Field) -> bool:
    """
    Determine if a field should be excluded from component auto-generation.

    Args:
        field_name: Name of the field
        field: Django Field instance

    Returns:
        True if field should be excluded
    """
    # Exact matches
    if field_name in POLYMORPHIC_EXCLUDE_FIELDS:
        return True

    # Pattern matches
    if any(pattern in field_name for pattern in POLYMORPHIC_EXCLUDE_PATTERNS):
        return True

    # Field properties
    if not field.editable:
        return True

    if hasattr(field, 'auto_now') and field.auto_now:
        return True

    if hasattr(field, 'auto_now_add') and field.auto_now_add:
        return True

    return False
```

## Implementation Recommendations

### 1. FieldInspector Enhancement

**Update**: `fairdm/utils/inspection.py`

The existing `FieldInspector` class already has correct exclusion logic:

```python
# Lines 28-40 - Already correct!
ALWAYS_EXCLUDE = [
    "id",
    "polymorphic_ctype",
    "polymorphic_ctype_id",
]

EXCLUDE_PATTERNS = [
    "_ptr",  # Polymorphic pointer fields
    "_ptr_id",
    "password",  # Security sensitive
]
```

**Recommendation**: Keep existing implementation - it's already correct and comprehensive.

### 2. Registry Subclass Detection

**Location**: `fairdm/registry/registry.py`

```python
class FairDMRegistry:
    """Central registry for FairDM models and their configurations."""

    def _is_sample_subclass(self, model: Type[models.Model]) -> bool:
        """Check if model is a Sample subclass."""
        from fairdm.core.models import Sample
        return issubclass(model, Sample)

    def _is_measurement_subclass(self, model: Type[models.Model]) -> bool:
        """Check if model is a Measurement subclass."""
        from fairdm.core.models import Measurement
        return issubclass(model, Measurement)

    @property
    def samples(self) -> list[Type[models.Model]]:
        """Returns all registered Sample model classes."""
        from fairdm.core.models import Sample
        return [
            config.model
            for config in self._registry.values()
            if issubclass(config.model, Sample)
        ]

    @property
    def measurements(self) -> list[Type[models.Model]]:
        """Returns all registered Measurement model classes."""
        from fairdm.core.models import Measurement
        return [
            config.model
            for config in self._registry.values()
            if issubclass(config.model, Measurement)
        ]

    def get_all_sample_subclasses(self) -> list[Type[models.Model]]:
        """
        Get all Sample subclasses recursively, including unregistered ones.
        Useful for introspection and validation.
        """
        from fairdm.core.models import Sample

        def get_recursive_subclasses(model):
            direct = model.__subclasses__()
            indirect = [sub for child in direct for sub in get_recursive_subclasses(child)]
            return direct + indirect

        return get_recursive_subclasses(Sample)

    def get_all_measurement_subclasses(self) -> list[Type[models.Model]]:
        """
        Get all Measurement subclasses recursively, including unregistered ones.
        """
        from fairdm.core.models import Measurement

        def get_recursive_subclasses(model):
            direct = model.__subclasses__()
            indirect = [sub for child in direct for sub in get_recursive_subclasses(child)]
            return direct + indirect

        return get_recursive_subclasses(Measurement)
```

### 3. Component Factory Field Resolution

**Location**: `fairdm/registry/factories.py`

```python
def get_safe_fields(model: Type[models.Model],
                   requested_fields: list[str] | None = None) -> list[str]:
    """
    Get safe field list for component generation, excluding polymorphic fields.

    Args:
        model: Django model class
        requested_fields: User-specified fields or None for auto-detection

    Returns:
        List of safe field names for component generation
    """
    from fairdm.utils.inspection import FieldInspector

    inspector = FieldInspector(model)

    if requested_fields:
        # Validate requested fields exist and are safe
        safe = []
        for field_name in requested_fields:
            if inspector.should_exclude_field(field_name):
                logger.warning(
                    f"Excluding polymorphic field '{field_name}' from {model.__name__} components"
                )
                continue
            safe.append(field_name)
        return safe
    else:
        # Auto-detect safe fields
        return inspector.get_safe_fields()
```

### 4. Admin Configuration

**Location**: Model-specific admin classes

```python
# For polymorphic child models in admin
from polymorphic.admin import PolymorphicChildModelAdmin

class CustomSampleAdmin(PolymorphicChildModelAdmin):
    base_model = Sample

    # Automatically handled - no need to include polymorphic fields
    fieldsets = (
        ('Sample Information', {
            'fields': ['name', 'dataset', 'location', 'status']
            # Note: polymorphic_ctype and sample_ptr are automatically excluded
        }),
    )
```

### 5. Testing Strategy

**Location**: `tests/test_polymorphic_fields.py`

```python
import pytest
from django.forms import ModelForm
from django_tables2 import Table
from django_filters import FilterSet

from fairdm_demo.models import CustomSample, ExampleMeasurement
from fairdm.registry import registry
from fairdm.utils.inspection import FieldInspector


class TestPolymorphicFieldExclusion:
    """Test that polymorphic fields are properly excluded."""

    def test_polymorphic_fields_excluded_from_form(self):
        """Ensure polymorphic fields don't appear in auto-generated forms."""
        config = registry.get_for_model(CustomSample)
        form_class = config.get_form_class()

        # These should NOT be in the form
        assert 'polymorphic_ctype' not in form_class.base_fields
        assert 'polymorphic_ctype_id' not in form_class.base_fields
        assert 'sample_ptr' not in form_class.base_fields
        assert 'sample_ptr_id' not in form_class.base_fields

    def test_polymorphic_fields_excluded_from_table(self):
        """Ensure polymorphic fields don't appear in auto-generated tables."""
        config = registry.get_for_model(CustomSample)
        table_class = config.get_table_class()

        # These should NOT be table columns
        assert 'polymorphic_ctype' not in table_class.base_columns
        assert 'sample_ptr' not in table_class.base_columns

    def test_polymorphic_fields_excluded_from_filterset(self):
        """Ensure polymorphic fields don't appear in auto-generated filters."""
        config = registry.get_for_model(CustomSample)
        filterset_class = config.get_filterset_class()

        # These should NOT be filters
        assert 'polymorphic_ctype' not in filterset_class.base_filters
        assert 'sample_ptr' not in filterset_class.base_filters

    def test_field_inspector_detects_ptr_fields(self):
        """Test FieldInspector correctly identifies pointer fields."""
        inspector = FieldInspector(CustomSample)

        assert inspector.should_exclude_field('sample_ptr')
        assert inspector.should_exclude_field('sample_ptr_id')
        assert inspector.should_exclude_field('measurement_ptr')
        assert inspector.should_exclude_field('polymorphic_ctype')
        assert inspector.should_exclude_field('polymorphic_ctype_id')

    def test_measurement_subclass_detection(self):
        """Test registry correctly identifies Measurement subclasses."""
        measurements = registry.measurements

        assert ExampleMeasurement in measurements
        assert CustomSample not in measurements

    def test_sample_subclass_detection(self):
        """Test registry correctly identifies Sample subclasses."""
        samples = registry.samples

        assert CustomSample in samples
        assert ExampleMeasurement not in samples

    def test_form_save_without_polymorphic_fields(self):
        """Test that forms can save without polymorphic field errors."""
        from fairdm.core.models import Dataset

        # Create test dataset
        dataset = Dataset.objects.create(name="Test Dataset")

        config = registry.get_for_model(CustomSample)
        form_class = config.get_form_class()

        # Form data without polymorphic fields
        data = {
            'name': 'Test Sample',
            'dataset': dataset.pk,
            'char_field': 'Test',
        }

        form = form_class(data=data)
        assert form.is_valid(), form.errors

        # Should save without AttributeError
        instance = form.save()
        assert instance.pk is not None
        assert instance.polymorphic_ctype is not None  # Auto-set by django-polymorphic


class TestPolymorphicQuerysets:
    """Test polymorphic queryset behavior with components."""

    def test_table_renders_mixed_sample_types(self):
        """Test that tables handle mixed polymorphic types correctly."""
        from fairdm.core.models import Sample

        # Create samples of different types
        # ... create CustomSample, CustomParentSample instances

        # Get all samples (polymorphic queryset)
        samples = Sample.objects.all()

        config = registry.get_for_model(Sample)
        table_class = config.get_table_class()
        table = table_class(samples)

        # Should render without errors
        html = table.as_html(None)
        assert html is not None

    def test_filterset_with_polymorphic_queryset(self):
        """Test that filters work with polymorphic querysets."""
        from fairdm.core.models import Sample

        config = registry.get_for_model(Sample)
        filterset_class = config.get_filterset_class()

        # Should handle polymorphic queryset
        filterset = filterset_class(queryset=Sample.objects.all())
        qs = filterset.qs

        # All instances should have correct types
        for sample in qs:
            assert hasattr(sample, 'polymorphic_ctype')
            assert sample._meta.model != Sample or len(Sample.__subclasses__()) == 0
```

## Code Examples

### Example 1: Field Detection in FieldInspector

```python
# From fairdm/utils/inspection.py (already implemented correctly)

class FieldInspector:
    ALWAYS_EXCLUDE = [
        "id",
        "polymorphic_ctype",
        "polymorphic_ctype_id",
    ]

    EXCLUDE_PATTERNS = [
        "_ptr",      # Polymorphic pointer fields
        "_ptr_id",
        "password",  # Security sensitive
    ]

    def should_exclude_field(self, field_name: str) -> bool:
        """Determine if a field should be excluded from auto-detection."""
        # Check always exclude list
        if field_name in self.ALWAYS_EXCLUDE:
            return True

        # Check patterns
        if any(pattern in field_name for pattern in self.EXCLUDE_PATTERNS):
            return True

        # Check field properties
        field = self.get_field(field_name)
        if field is None:
            return True

        # Exclude non-editable, auto_now, auto_now_add
        if not field.editable:
            return True
        if hasattr(field, "auto_now") and field.auto_now:
            return True
        if hasattr(field, "auto_now_add") and field.auto_now_add:
            return True

        return False
```

### Example 2: Safe Field List Generation

```python
def get_safe_fields_for_model(model: Type[models.Model]) -> list[str]:
    """
    Get list of safe fields for a model, excluding polymorphic technical fields.

    Args:
        model: Django model class

    Returns:
        List of field names safe for component generation
    """
    from fairdm.utils.inspection import FieldInspector

    inspector = FieldInspector(model)
    all_fields = [f.name for f in model._meta.get_fields()]

    safe_fields = [
        field_name
        for field_name in all_fields
        if not inspector.should_exclude_field(field_name)
    ]

    return safe_fields


# Usage in registry
from fairdm_demo.models import CustomSample

safe_fields = get_safe_fields_for_model(CustomSample)
# Returns: ['name', 'dataset', 'uuid', 'local_id', 'status',
#           'location', 'char_field', 'text_field', ...]
# Excludes: 'id', 'polymorphic_ctype', 'polymorphic_ctype_id',
#           'sample_ptr', 'sample_ptr_id', 'added', 'modified'
```

### Example 3: Polymorphic-Safe Form Factory

```python
def create_polymorphic_safe_form(model: Type[models.Model],
                                 fields: list[str] | None = None) -> Type[ModelForm]:
    """
    Create a ModelForm that excludes polymorphic technical fields.

    Args:
        model: Django model class
        fields: Optional list of fields to include

    Returns:
        ModelForm class
    """
    from django.forms import ModelForm
    from fairdm.utils.inspection import FieldInspector

    inspector = FieldInspector(model)

    if fields is None:
        # Auto-detect safe fields
        fields = [
            f.name
            for f in model._meta.get_fields()
            if isinstance(f, Field) and not inspector.should_exclude_field(f.name)
        ]
    else:
        # Filter requested fields
        fields = [
            field_name
            for field_name in fields
            if not inspector.should_exclude_field(field_name)
        ]

    class SafeModelForm(ModelForm):
        class Meta:
            model = model
            fields = fields

    return SafeModelForm


# Usage
from fairdm_demo.models import CustomSample

FormClass = create_polymorphic_safe_form(CustomSample)
# Form will not include polymorphic_ctype, sample_ptr, etc.
```

### Example 4: Registry Subclass Detection

```python
class FairDMRegistry:
    def get_samples_by_inheritance_level(self) -> dict[int, list[Type]]:
        """
        Get Sample subclasses grouped by inheritance depth.

        Returns:
            Dictionary mapping depth to list of model classes
            Depth 0: Sample base class
            Depth 1: Direct Sample subclasses
            Depth 2: Subclasses of Sample subclasses, etc.
        """
        from fairdm.core.models import Sample

        def get_inheritance_depth(model, base=Sample, depth=0):
            if model == base:
                return depth
            for parent in model.__bases__:
                if issubclass(parent, base):
                    return get_inheritance_depth(parent, base, depth + 1)
            return depth

        result = {}
        for model in self.get_all_sample_subclasses():
            depth = get_inheritance_depth(model)
            if depth not in result:
                result[depth] = []
            result[depth].append(model)

        return result


# Usage
registry = FairDMRegistry()
samples_by_depth = registry.get_samples_by_inheritance_level()
# {
#     1: [CustomSample, CustomParentSample],  # Direct Sample subclasses
#     2: [VerySpecificSample],  # Subclass of CustomParentSample
# }
```

## Validation Against FR-016

**FR-016 Requirement**:
> The registry MUST handle polymorphic querysets correctly by detecting polymorphic models using `Model.__subclasses__()` and providing introspection methods that correctly categorize Sample vs Measurement subclasses

**Validation**:

✅ **Detection Method**: Use `Model.__subclasses__()` as specified

- Recommended implementation uses `Sample.__subclasses__()` and `Measurement.__subclasses__()`
- Includes recursive detection for multi-level inheritance

✅ **Introspection Methods**: Correctly categorize Sample vs Measurement

- `registry.samples` property returns only Sample subclasses
- `registry.measurements` property returns only Measurement subclasses
- Uses `issubclass()` check for accurate categorization

✅ **Polymorphic Queryset Handling**: Works correctly with components

- Django-tables2, django-filter, and DRF work transparently with polymorphic querysets
- No special handling needed in component factories
- Polymorphic fields correctly excluded to prevent form errors

## Alternatives Considered

### Alternative 1: Whitelist Approach

**Considered**: Only include explicitly safe fields, ignore everything else.

**Rejected Because**:

- Reduces discoverability of user-defined fields
- Requires developers to manually specify every field
- Doesn't align with "sensible defaults" philosophy from spec

### Alternative 2: Include Polymorphic Fields in Read-Only Mode

**Considered**: Include `polymorphic_ctype` as read-only field in forms/admin.

**Rejected Because**:

- Adds visual clutter with no user benefit
- ContentType display (e.g., "fairdm_demo | custom sample") is not user-friendly
- Field is purely technical metadata
- Users shouldn't need to think about polymorphic implementation details

### Alternative 3: Custom Widget for Polymorphic Fields

**Considered**: Create special widget that displays type information nicely.

**Rejected Because**:

- Adds complexity for minimal gain
- Type information is better shown through model name/verbose_name
- Widget development cost outweighs benefits
- Better UX: show "Thin Section" (verbose_name) than "CustomSample" (ContentType)

### Alternative 4: Separate FilterSets Per Polymorphic Type

**Considered**: Generate child-specific FilterSets instead of base FilterSet.

**Accepted for Child Models**: This is actually a good pattern!

- Child-specific FilterSets can filter on child-specific fields
- Base FilterSet only filters on common fields
- Registry should support both patterns

**Implementation**:

```python
# Base Sample FilterSet - only common fields
class SampleFilter(FilterSet):
    class Meta:
        model = Sample
        fields = ['name', 'dataset', 'status', 'location']

# Child-specific FilterSet - includes child fields
class CustomSampleFilter(FilterSet):
    class Meta:
        model = CustomSample
        fields = ['name', 'dataset', 'char_field', 'text_field', 'integer_field']
```

## Special Considerations

### 1. Django Admin Integration

- Use `PolymorphicChildModelAdmin` for child models
- Always add parent pointer fields to `readonly_fields` for inlines
- Set `show_in_index = True/False` based on whether child models should appear in admin index

### 2. REST API Serializers

- Polymorphic querysets work with DRF serializers
- Explicitly exclude polymorphic fields in serializer Meta
- Consider nested serializers for ForeignKey relationships
- Use `to_representation()` to handle type-specific serialization

### 3. Form Handling

- Never include `polymorphic_ctype` or `_ptr` fields in forms
- Django-polymorphic automatically manages these fields on save
- Form validation should use `model._meta.get_field()` to check field existence

### 4. Import/Export Resources

- Exclude polymorphic fields from CSV export
- ContentType is internal implementation detail, not data
- On import, django-polymorphic auto-sets correct ContentType

### 5. Query Optimization

- Use `select_related('polymorphic_ctype')` to avoid N+1 queries
- Use `non_polymorphic()` when only base fields needed
- Polymorphic queries fetch child tables, so be mindful of JOIN count

### 6. Testing Considerations

- Test form save with mixed polymorphic types
- Test that tables render correctly with heterogeneous querysets
- Test filters work across different child types
- Test admin inline save doesn't raise AttributeError

## Summary and Recommendations

### Key Decisions

1. **Exclude ALL polymorphic technical fields**: `polymorphic_ctype`, `polymorphic_ctype_id`, and all `_ptr`/`_ptr_id` fields
2. **Use existing FieldInspector exclusion logic**: Already correctly implemented in `fairdm/utils/inspection.py`
3. **Detect subclasses with `Model.__subclasses__()`**: As specified in FR-016
4. **No special handling for querysets**: Django-tables2 and django-filter work transparently
5. **Support both base and child-specific components**: FilterSets, Tables, Forms can be generated for either

### Implementation Priority

**High Priority** (P0):

1. ✅ Ensure `FieldInspector` exclusion logic is used in all component factories
2. ✅ Implement `registry.samples` and `registry.measurements` properties
3. ✅ Add tests for polymorphic field exclusion

**Medium Priority** (P1):
4. Implement recursive subclass detection for multi-level inheritance
5. Add validation warnings when users try to include polymorphic fields
6. Document polymorphic best practices in registry docs

**Low Priority** (P2):
7. Add helper methods for inheritance depth analysis
8. Create admin mixins for common polymorphic patterns
9. Build examples showing base vs child FilterSet patterns

### Success Criteria

- ✅ Forms can save without `AttributeError: can't set attribute`
- ✅ Tables render heterogeneous polymorphic querysets correctly
- ✅ FilterSets filter mixed-type querysets without errors
- ✅ Registry correctly categorizes Sample vs Measurement subclasses
- ✅ No polymorphic technical fields appear in generated components
- ✅ Tests pass for all polymorphic scenarios

## References

- **Django-polymorphic Documentation**: <https://django-polymorphic.readthedocs.io/>
- **FR-016 Specification**: [specs/004-fairdm-registry/spec.md#L99](../spec.md#L99)
- **FieldInspector Implementation**: [fairdm/utils/inspection.py](../../../fairdm/utils/inspection.py)
- **Sample Model**: [fairdm/core/sample/models.py](../../../fairdm/core/sample/models.py)
- **Measurement Model**: [fairdm/core/measurement/models.py](../../../fairdm/core/measurement/models.py)
- **Test Models**: [fairdm_demo/models.py](../../../fairdm_demo/models.py)

---

**Research Complete**: All questions answered with specific field names, implementation examples, and validation against requirements.
